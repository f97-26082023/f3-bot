/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v1.5.6
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2022-04-04T03:54:41+00:00 
 *
 * The version of the OpenAPI document: 1.5.6
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AttachmentArray } from '../model';
// @ts-ignore
import { PiggyBankEventArray } from '../model';
// @ts-ignore
import { TransactionArray } from '../model';
// @ts-ignore
import { TransactionLinkArray } from '../model';
// @ts-ignore
import { TransactionSingle } from '../model';
// @ts-ignore
import { TransactionStore } from '../model';
// @ts-ignore
import { TransactionTypeFilter } from '../model';
// @ts-ignore
import { TransactionUpdate } from '../model';
// @ts-ignore
import { ValidationError } from '../model';
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a transaction.
         * @summary Delete a transaction.
         * @param {string} id The ID of the transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransaction', 'id', id)
            const localVarPath = `/api/v1/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an individual journal (split) from a transaction.
         * @summary Delete split from transaction
         * @param {string} id The ID of the transaction journal (the split) you wish to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionJournal: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransactionJournal', 'id', id)
            const localVarPath = `/api/v1/transaction-journals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single transaction.
         * @summary Get a single transaction.
         * @param {string} id The ID of the transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransaction', 'id', id)
            const localVarPath = `/api/v1/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single transaction by underlying journal (split).
         * @summary Get a single transaction, based on one of the underlying transaction journals (transaction splits).
         * @param {string} id The ID of the transaction journal (split).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByJournal: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransactionByJournal', 'id', id)
            const localVarPath = `/api/v1/transaction-journals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the transaction.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByTransaction: async (id: string, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAttachmentByTransaction', 'id', id)
            const localVarPath = `/api/v1/transactions/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all piggy bank events.
         * @summary Lists all piggy bank events.
         * @param {string} id The ID of the transaction.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventByTransaction: async (id: string, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listEventByTransaction', 'id', id)
            const localVarPath = `/api/v1/transactions/{id}/piggy_bank_events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all the transaction links for an individual journal (a split). Don\'t use the group ID, you need the actual underlying journal (the split).
         * @summary Lists all the transaction links for an individual journal (individual split).
         * @param {string} id The ID of the transaction journal / the split.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLinksByJournal: async (id: string, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listLinksByJournal', 'id', id)
            const localVarPath = `/api/v1/transaction-journals/{id}/links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the user\'s transactions.
         * @summary List all the user\'s transactions. 
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransaction: async (page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new transaction
         * @param {TransactionStore} transactionStore JSON array or key&#x3D;value pairs with the necessary transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTransaction: async (transactionStore: TransactionStore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionStore' is not null or undefined
            assertParamExists('storeTransaction', 'transactionStore', transactionStore)
            const localVarPath = `/api/v1/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing transaction.
         * @summary Update existing transaction. For more information, see https://docs.firefly-iii.org/firefly-iii/api/specials
         * @param {string} id The ID of the transaction.
         * @param {TransactionUpdate} transactionUpdate JSON array with updated transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction: async (id: string, transactionUpdate: TransactionUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTransaction', 'id', id)
            // verify required parameter 'transactionUpdate' is not null or undefined
            assertParamExists('updateTransaction', 'transactionUpdate', transactionUpdate)
            const localVarPath = `/api/v1/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a transaction.
         * @summary Delete a transaction.
         * @param {string} id The ID of the transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransaction(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransaction(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an individual journal (split) from a transaction.
         * @summary Delete split from transaction
         * @param {string} id The ID of the transaction journal (the split) you wish to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransactionJournal(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransactionJournal(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single transaction.
         * @summary Get a single transaction.
         * @param {string} id The ID of the transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransaction(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransaction(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single transaction by underlying journal (split).
         * @summary Get a single transaction, based on one of the underlying transaction journals (transaction splits).
         * @param {string} id The ID of the transaction journal (split).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionByJournal(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionByJournal(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the transaction.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentByTransaction(id: string, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentByTransaction(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all piggy bank events.
         * @summary Lists all piggy bank events.
         * @param {string} id The ID of the transaction.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventByTransaction(id: string, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PiggyBankEventArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventByTransaction(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all the transaction links for an individual journal (a split). Don\'t use the group ID, you need the actual underlying journal (the split).
         * @summary Lists all the transaction links for an individual journal (individual split).
         * @param {string} id The ID of the transaction journal / the split.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLinksByJournal(id: string, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionLinkArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLinksByJournal(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the user\'s transactions.
         * @summary List all the user\'s transactions. 
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransaction(page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransaction(page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new transaction
         * @param {TransactionStore} transactionStore JSON array or key&#x3D;value pairs with the necessary transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeTransaction(transactionStore: TransactionStore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeTransaction(transactionStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing transaction.
         * @summary Update existing transaction. For more information, see https://docs.firefly-iii.org/firefly-iii/api/specials
         * @param {string} id The ID of the transaction.
         * @param {TransactionUpdate} transactionUpdate JSON array with updated transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransaction(id: string, transactionUpdate: TransactionUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransaction(id, transactionUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Delete a transaction.
         * @summary Delete a transaction.
         * @param {string} id The ID of the transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTransaction(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an individual journal (split) from a transaction.
         * @summary Delete split from transaction
         * @param {string} id The ID of the transaction journal (the split) you wish to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionJournal(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTransactionJournal(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single transaction.
         * @summary Get a single transaction.
         * @param {string} id The ID of the transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(id: string, options?: any): AxiosPromise<TransactionSingle> {
            return localVarFp.getTransaction(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single transaction by underlying journal (split).
         * @summary Get a single transaction, based on one of the underlying transaction journals (transaction splits).
         * @param {string} id The ID of the transaction journal (split).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByJournal(id: string, options?: any): AxiosPromise<TransactionSingle> {
            return localVarFp.getTransactionByJournal(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the transaction.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByTransaction(id: string, page?: number, options?: any): AxiosPromise<AttachmentArray> {
            return localVarFp.listAttachmentByTransaction(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all piggy bank events.
         * @summary Lists all piggy bank events.
         * @param {string} id The ID of the transaction.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventByTransaction(id: string, page?: number, options?: any): AxiosPromise<PiggyBankEventArray> {
            return localVarFp.listEventByTransaction(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the transaction links for an individual journal (a split). Don\'t use the group ID, you need the actual underlying journal (the split).
         * @summary Lists all the transaction links for an individual journal (individual split).
         * @param {string} id The ID of the transaction journal / the split.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLinksByJournal(id: string, page?: number, options?: any): AxiosPromise<TransactionLinkArray> {
            return localVarFp.listLinksByJournal(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the user\'s transactions.
         * @summary List all the user\'s transactions. 
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransaction(page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransaction(page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new transaction
         * @param {TransactionStore} transactionStore JSON array or key&#x3D;value pairs with the necessary transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTransaction(transactionStore: TransactionStore, options?: any): AxiosPromise<TransactionSingle> {
            return localVarFp.storeTransaction(transactionStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing transaction.
         * @summary Update existing transaction. For more information, see https://docs.firefly-iii.org/firefly-iii/api/specials
         * @param {string} id The ID of the transaction.
         * @param {TransactionUpdate} transactionUpdate JSON array with updated transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(id: string, transactionUpdate: TransactionUpdate, options?: any): AxiosPromise<TransactionSingle> {
            return localVarFp.updateTransaction(id, transactionUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiDeleteTransactionRequest
 */
export interface TransactionsApiDeleteTransactionRequest {
    /**
     * The ID of the transaction.
     * @type {string}
     * @memberof TransactionsApiDeleteTransaction
     */
    readonly id: string
}

/**
 * Request parameters for deleteTransactionJournal operation in TransactionsApi.
 * @export
 * @interface TransactionsApiDeleteTransactionJournalRequest
 */
export interface TransactionsApiDeleteTransactionJournalRequest {
    /**
     * The ID of the transaction journal (the split) you wish to delete.
     * @type {string}
     * @memberof TransactionsApiDeleteTransactionJournal
     */
    readonly id: string
}

/**
 * Request parameters for getTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiGetTransactionRequest
 */
export interface TransactionsApiGetTransactionRequest {
    /**
     * The ID of the transaction.
     * @type {string}
     * @memberof TransactionsApiGetTransaction
     */
    readonly id: string
}

/**
 * Request parameters for getTransactionByJournal operation in TransactionsApi.
 * @export
 * @interface TransactionsApiGetTransactionByJournalRequest
 */
export interface TransactionsApiGetTransactionByJournalRequest {
    /**
     * The ID of the transaction journal (split).
     * @type {string}
     * @memberof TransactionsApiGetTransactionByJournal
     */
    readonly id: string
}

/**
 * Request parameters for listAttachmentByTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiListAttachmentByTransactionRequest
 */
export interface TransactionsApiListAttachmentByTransactionRequest {
    /**
     * The ID of the transaction.
     * @type {string}
     * @memberof TransactionsApiListAttachmentByTransaction
     */
    readonly id: string

    /**
     * Page number. The default pagination is 50.
     * @type {number}
     * @memberof TransactionsApiListAttachmentByTransaction
     */
    readonly page?: number
}

/**
 * Request parameters for listEventByTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiListEventByTransactionRequest
 */
export interface TransactionsApiListEventByTransactionRequest {
    /**
     * The ID of the transaction.
     * @type {string}
     * @memberof TransactionsApiListEventByTransaction
     */
    readonly id: string

    /**
     * Page number. The default pagination is 50.
     * @type {number}
     * @memberof TransactionsApiListEventByTransaction
     */
    readonly page?: number
}

/**
 * Request parameters for listLinksByJournal operation in TransactionsApi.
 * @export
 * @interface TransactionsApiListLinksByJournalRequest
 */
export interface TransactionsApiListLinksByJournalRequest {
    /**
     * The ID of the transaction journal / the split.
     * @type {string}
     * @memberof TransactionsApiListLinksByJournal
     */
    readonly id: string

    /**
     * Page number. The default pagination is 50.
     * @type {number}
     * @memberof TransactionsApiListLinksByJournal
     */
    readonly page?: number
}

/**
 * Request parameters for listTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiListTransactionRequest
 */
export interface TransactionsApiListTransactionRequest {
    /**
     * Page number. The default pagination is 50.
     * @type {number}
     * @memberof TransactionsApiListTransaction
     */
    readonly page?: number

    /**
     * A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
     * @type {string}
     * @memberof TransactionsApiListTransaction
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
     * @type {string}
     * @memberof TransactionsApiListTransaction
     */
    readonly end?: string

    /**
     * Optional filter on the transaction type(s) returned.
     * @type {TransactionTypeFilter}
     * @memberof TransactionsApiListTransaction
     */
    readonly type?: TransactionTypeFilter
}

/**
 * Request parameters for storeTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiStoreTransactionRequest
 */
export interface TransactionsApiStoreTransactionRequest {
    /**
     * JSON array or key&#x3D;value pairs with the necessary transaction information. See the model for the exact specifications.
     * @type {TransactionStore}
     * @memberof TransactionsApiStoreTransaction
     */
    readonly transactionStore: TransactionStore
}

/**
 * Request parameters for updateTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiUpdateTransactionRequest
 */
export interface TransactionsApiUpdateTransactionRequest {
    /**
     * The ID of the transaction.
     * @type {string}
     * @memberof TransactionsApiUpdateTransaction
     */
    readonly id: string

    /**
     * JSON array with updated transaction information. See the model for the exact specifications.
     * @type {TransactionUpdate}
     * @memberof TransactionsApiUpdateTransaction
     */
    readonly transactionUpdate: TransactionUpdate
}

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Delete a transaction.
     * @summary Delete a transaction.
     * @param {TransactionsApiDeleteTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public deleteTransaction(requestParameters: TransactionsApiDeleteTransactionRequest, options?: any) {
        return TransactionsApiFp(this.configuration).deleteTransaction(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an individual journal (split) from a transaction.
     * @summary Delete split from transaction
     * @param {TransactionsApiDeleteTransactionJournalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public deleteTransactionJournal(requestParameters: TransactionsApiDeleteTransactionJournalRequest, options?: any) {
        return TransactionsApiFp(this.configuration).deleteTransactionJournal(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single transaction.
     * @summary Get a single transaction.
     * @param {TransactionsApiGetTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransaction(requestParameters: TransactionsApiGetTransactionRequest, options?: any) {
        return TransactionsApiFp(this.configuration).getTransaction(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single transaction by underlying journal (split).
     * @summary Get a single transaction, based on one of the underlying transaction journals (transaction splits).
     * @param {TransactionsApiGetTransactionByJournalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionByJournal(requestParameters: TransactionsApiGetTransactionByJournalRequest, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionByJournal(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all attachments.
     * @summary Lists all attachments.
     * @param {TransactionsApiListAttachmentByTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listAttachmentByTransaction(requestParameters: TransactionsApiListAttachmentByTransactionRequest, options?: any) {
        return TransactionsApiFp(this.configuration).listAttachmentByTransaction(requestParameters.id, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all piggy bank events.
     * @summary Lists all piggy bank events.
     * @param {TransactionsApiListEventByTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listEventByTransaction(requestParameters: TransactionsApiListEventByTransactionRequest, options?: any) {
        return TransactionsApiFp(this.configuration).listEventByTransaction(requestParameters.id, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all the transaction links for an individual journal (a split). Don\'t use the group ID, you need the actual underlying journal (the split).
     * @summary Lists all the transaction links for an individual journal (individual split).
     * @param {TransactionsApiListLinksByJournalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listLinksByJournal(requestParameters: TransactionsApiListLinksByJournalRequest, options?: any) {
        return TransactionsApiFp(this.configuration).listLinksByJournal(requestParameters.id, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the user\'s transactions.
     * @summary List all the user\'s transactions. 
     * @param {TransactionsApiListTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listTransaction(requestParameters: TransactionsApiListTransactionRequest = {}, options?: any) {
        return TransactionsApiFp(this.configuration).listTransaction(requestParameters.page, requestParameters.start, requestParameters.end, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new transaction
     * @param {TransactionsApiStoreTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public storeTransaction(requestParameters: TransactionsApiStoreTransactionRequest, options?: any) {
        return TransactionsApiFp(this.configuration).storeTransaction(requestParameters.transactionStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing transaction.
     * @summary Update existing transaction. For more information, see https://docs.firefly-iii.org/firefly-iii/api/specials
     * @param {TransactionsApiUpdateTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public updateTransaction(requestParameters: TransactionsApiUpdateTransactionRequest, options?: any) {
        return TransactionsApiFp(this.configuration).updateTransaction(requestParameters.id, requestParameters.transactionUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}
