/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v1.5.6
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2022-04-04T03:54:41+00:00 
 *
 * The version of the OpenAPI document: 1.5.6
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { RuleArray } from '../model';
// @ts-ignore
import { RuleSingle } from '../model';
// @ts-ignore
import { RuleStore } from '../model';
// @ts-ignore
import { RuleUpdate } from '../model';
// @ts-ignore
import { TransactionArray } from '../model';
// @ts-ignore
import { ValidationError } from '../model';
/**
 * RulesApi - axios parameter creator
 * @export
 */
export const RulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an rule.
         * @summary Delete an rule.
         * @param {string} id The ID of the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRule', 'id', id)
            const localVarPath = `/api/v1/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the group! Limit the result if you want to.
         * @summary Fire the rule on your transactions.
         * @param {string} id The ID of the rule.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the start date is not present, it will be set to one year ago. If you use this field, both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the end date is not present, it will be set to today. If you use this field, both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the triggering of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireRule: async (id: string, start?: string, end?: string, accounts?: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fireRule', 'id', id)
            const localVarPath = `/api/v1/rules/{id}/trigger`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single rule.
         * @summary Get a single rule.
         * @param {string} id The ID of the object.X
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRule', 'id', id)
            const localVarPath = `/api/v1/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all rules.
         * @summary List all rules.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRule: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new rule. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule
         * @param {RuleStore} ruleStore JSON array or key&#x3D;value pairs with the necessary rule information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRule: async (ruleStore: RuleStore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleStore' is not null or undefined
            assertParamExists('storeRule', 'ruleStore', ruleStore)
            const localVarPath = `/api/v1/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test which transactions would be hit by the rule. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule. No changes will be made.
         * @param {string} id The ID of the rule.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the testing of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRule: async (id: string, start?: string, end?: string, accounts?: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('testRule', 'id', id)
            const localVarPath = `/api/v1/rules/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing rule.
         * @summary Update existing rule.
         * @param {string} id The ID of the object.X
         * @param {RuleUpdate} ruleUpdate JSON array with updated rule information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRule: async (id: string, ruleUpdate: RuleUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRule', 'id', id)
            // verify required parameter 'ruleUpdate' is not null or undefined
            assertParamExists('updateRule', 'ruleUpdate', ruleUpdate)
            const localVarPath = `/api/v1/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulesApi - functional programming interface
 * @export
 */
export const RulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an rule.
         * @summary Delete an rule.
         * @param {string} id The ID of the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRule(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the group! Limit the result if you want to.
         * @summary Fire the rule on your transactions.
         * @param {string} id The ID of the rule.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the start date is not present, it will be set to one year ago. If you use this field, both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the end date is not present, it will be set to today. If you use this field, both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the triggering of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fireRule(id: string, start?: string, end?: string, accounts?: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fireRule(id, start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single rule.
         * @summary Get a single rule.
         * @param {string} id The ID of the object.X
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRule(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all rules.
         * @summary List all rules.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRule(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRule(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new rule. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule
         * @param {RuleStore} ruleStore JSON array or key&#x3D;value pairs with the necessary rule information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeRule(ruleStore: RuleStore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeRule(ruleStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test which transactions would be hit by the rule. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule. No changes will be made.
         * @param {string} id The ID of the rule.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the testing of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testRule(id: string, start?: string, end?: string, accounts?: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testRule(id, start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing rule.
         * @summary Update existing rule.
         * @param {string} id The ID of the object.X
         * @param {RuleUpdate} ruleUpdate JSON array with updated rule information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRule(id: string, ruleUpdate: RuleUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRule(id, ruleUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RulesApi - factory interface
 * @export
 */
export const RulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RulesApiFp(configuration)
    return {
        /**
         * Delete an rule.
         * @summary Delete an rule.
         * @param {string} id The ID of the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the group! Limit the result if you want to.
         * @summary Fire the rule on your transactions.
         * @param {string} id The ID of the rule.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the start date is not present, it will be set to one year ago. If you use this field, both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the end date is not present, it will be set to today. If you use this field, both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the triggering of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireRule(id: string, start?: string, end?: string, accounts?: Array<number>, options?: any): AxiosPromise<void> {
            return localVarFp.fireRule(id, start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single rule.
         * @summary Get a single rule.
         * @param {string} id The ID of the object.X
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule(id: string, options?: any): AxiosPromise<RuleSingle> {
            return localVarFp.getRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all rules.
         * @summary List all rules.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRule(page?: number, options?: any): AxiosPromise<RuleArray> {
            return localVarFp.listRule(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new rule. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule
         * @param {RuleStore} ruleStore JSON array or key&#x3D;value pairs with the necessary rule information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRule(ruleStore: RuleStore, options?: any): AxiosPromise<RuleSingle> {
            return localVarFp.storeRule(ruleStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Test which transactions would be hit by the rule. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule. No changes will be made.
         * @param {string} id The ID of the rule.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the testing of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRule(id: string, start?: string, end?: string, accounts?: Array<number>, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.testRule(id, start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing rule.
         * @summary Update existing rule.
         * @param {string} id The ID of the object.X
         * @param {RuleUpdate} ruleUpdate JSON array with updated rule information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRule(id: string, ruleUpdate: RuleUpdate, options?: any): AxiosPromise<RuleSingle> {
            return localVarFp.updateRule(id, ruleUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteRule operation in RulesApi.
 * @export
 * @interface RulesApiDeleteRuleRequest
 */
export interface RulesApiDeleteRuleRequest {
    /**
     * The ID of the rule.
     * @type {string}
     * @memberof RulesApiDeleteRule
     */
    readonly id: string
}

/**
 * Request parameters for fireRule operation in RulesApi.
 * @export
 * @interface RulesApiFireRuleRequest
 */
export interface RulesApiFireRuleRequest {
    /**
     * The ID of the rule.
     * @type {string}
     * @memberof RulesApiFireRule
     */
    readonly id: string

    /**
     * A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the start date is not present, it will be set to one year ago. If you use this field, both the start date and the end date must be present. 
     * @type {string}
     * @memberof RulesApiFireRule
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the end date is not present, it will be set to today. If you use this field, both the start date and the end date must be present. 
     * @type {string}
     * @memberof RulesApiFireRule
     */
    readonly end?: string

    /**
     * Limit the triggering of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
     * @type {Array<number>}
     * @memberof RulesApiFireRule
     */
    readonly accounts?: Array<number>
}

/**
 * Request parameters for getRule operation in RulesApi.
 * @export
 * @interface RulesApiGetRuleRequest
 */
export interface RulesApiGetRuleRequest {
    /**
     * The ID of the object.X
     * @type {string}
     * @memberof RulesApiGetRule
     */
    readonly id: string
}

/**
 * Request parameters for listRule operation in RulesApi.
 * @export
 * @interface RulesApiListRuleRequest
 */
export interface RulesApiListRuleRequest {
    /**
     * Page number. The default pagination is 50.
     * @type {number}
     * @memberof RulesApiListRule
     */
    readonly page?: number
}

/**
 * Request parameters for storeRule operation in RulesApi.
 * @export
 * @interface RulesApiStoreRuleRequest
 */
export interface RulesApiStoreRuleRequest {
    /**
     * JSON array or key&#x3D;value pairs with the necessary rule information. See the model for the exact specifications.
     * @type {RuleStore}
     * @memberof RulesApiStoreRule
     */
    readonly ruleStore: RuleStore
}

/**
 * Request parameters for testRule operation in RulesApi.
 * @export
 * @interface RulesApiTestRuleRequest
 */
export interface RulesApiTestRuleRequest {
    /**
     * The ID of the rule.
     * @type {string}
     * @memberof RulesApiTestRule
     */
    readonly id: string

    /**
     * A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
     * @type {string}
     * @memberof RulesApiTestRule
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
     * @type {string}
     * @memberof RulesApiTestRule
     */
    readonly end?: string

    /**
     * Limit the testing of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
     * @type {Array<number>}
     * @memberof RulesApiTestRule
     */
    readonly accounts?: Array<number>
}

/**
 * Request parameters for updateRule operation in RulesApi.
 * @export
 * @interface RulesApiUpdateRuleRequest
 */
export interface RulesApiUpdateRuleRequest {
    /**
     * The ID of the object.X
     * @type {string}
     * @memberof RulesApiUpdateRule
     */
    readonly id: string

    /**
     * JSON array with updated rule information. See the model for the exact specifications.
     * @type {RuleUpdate}
     * @memberof RulesApiUpdateRule
     */
    readonly ruleUpdate: RuleUpdate
}

/**
 * RulesApi - object-oriented interface
 * @export
 * @class RulesApi
 * @extends {BaseAPI}
 */
export class RulesApi extends BaseAPI {
    /**
     * Delete an rule.
     * @summary Delete an rule.
     * @param {RulesApiDeleteRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public deleteRule(requestParameters: RulesApiDeleteRuleRequest, options?: any) {
        return RulesApiFp(this.configuration).deleteRule(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fire the rule group on your transactions. Changes will be made by the rules in the group! Limit the result if you want to.
     * @summary Fire the rule on your transactions.
     * @param {RulesApiFireRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public fireRule(requestParameters: RulesApiFireRuleRequest, options?: any) {
        return RulesApiFp(this.configuration).fireRule(requestParameters.id, requestParameters.start, requestParameters.end, requestParameters.accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single rule.
     * @summary Get a single rule.
     * @param {RulesApiGetRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getRule(requestParameters: RulesApiGetRuleRequest, options?: any) {
        return RulesApiFp(this.configuration).getRule(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all rules.
     * @summary List all rules.
     * @param {RulesApiListRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public listRule(requestParameters: RulesApiListRuleRequest = {}, options?: any) {
        return RulesApiFp(this.configuration).listRule(requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new rule. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new rule
     * @param {RulesApiStoreRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public storeRule(requestParameters: RulesApiStoreRuleRequest, options?: any) {
        return RulesApiFp(this.configuration).storeRule(requestParameters.ruleStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test which transactions would be hit by the rule. No changes will be made. Limit the result if you want to.
     * @summary Test which transactions would be hit by the rule. No changes will be made.
     * @param {RulesApiTestRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public testRule(requestParameters: RulesApiTestRuleRequest, options?: any) {
        return RulesApiFp(this.configuration).testRule(requestParameters.id, requestParameters.start, requestParameters.end, requestParameters.accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing rule.
     * @summary Update existing rule.
     * @param {RulesApiUpdateRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public updateRule(requestParameters: RulesApiUpdateRuleRequest, options?: any) {
        return RulesApiFp(this.configuration).updateRule(requestParameters.id, requestParameters.ruleUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}
