/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v1.5.6
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2022-04-04T03:54:41+00:00 
 *
 * The version of the OpenAPI document: 1.5.6
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ValidationError } from '../model';
// @ts-ignore
import { WebhookArray } from '../model';
// @ts-ignore
import { WebhookAttemptArray } from '../model';
// @ts-ignore
import { WebhookAttemptSingle } from '../model';
// @ts-ignore
import { WebhookMessageArray } from '../model';
// @ts-ignore
import { WebhookMessageSingle } from '../model';
// @ts-ignore
import { WebhookSingle } from '../model';
// @ts-ignore
import { WebhookStore } from '../model';
// @ts-ignore
import { WebhookUpdate } from '../model';
/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a webhook.
         * @summary Delete a webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWebhook', 'id', id)
            const localVarPath = `/api/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook message. Any time a webhook is triggered the message is stored before it\'s sent. You can delete them before or after sending.
         * @summary Delete a webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookMessage: async (id: string, messageId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWebhookMessage', 'id', id)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteWebhookMessage', 'messageId', messageId)
            const localVarPath = `/api/v1/webhooks/{id}/messages/{messageId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook message attempt. If you delete all attempts for a webhook message, Firefly III will (once again) assume all is well with the webhook message and will try to send it again.
         * @summary Delete a webhook attempt.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook message attempt ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookMessageAttempt: async (id: string, messageId: number, attemptId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWebhookMessageAttempt', 'id', id)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteWebhookMessageAttempt', 'messageId', messageId)
            // verify required parameter 'attemptId' is not null or undefined
            assertParamExists('deleteWebhookMessageAttempt', 'attemptId', attemptId)
            const localVarPath = `/api/v1/webhooks/{id}/messages/{messageId}/attempts/{attemptId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"attemptId"}}`, encodeURIComponent(String(attemptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When a webhook is triggered it will store the actual content of the webhook in a webhook message. You can view and analyse a single one using this endpoint.
         * @summary Get a single message from a webhook.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWebhookMessage: async (id: string, messageId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleWebhookMessage', 'id', id)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getSingleWebhookMessage', 'messageId', messageId)
            const localVarPath = `/api/v1/webhooks/{id}/messages/{messageId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhooks messages that receive too many attempts (failures) will not be fired. You must first clear out old attempts and try again. This endpoint shows you the details of a single attempt. The ID of the attempt must match the corresponding webhook and webhook message.
         * @summary Get a single failed attempt from a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook attempt ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWebhookMessageAttempt: async (id: string, messageId: number, attemptId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleWebhookMessageAttempt', 'id', id)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getSingleWebhookMessageAttempt', 'messageId', messageId)
            // verify required parameter 'attemptId' is not null or undefined
            assertParamExists('getSingleWebhookMessageAttempt', 'attemptId', attemptId)
            const localVarPath = `/api/v1/webhooks/{id}/messages/{messageId}/attempts/{attemptId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"attemptId"}}`, encodeURIComponent(String(attemptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all info of a single webhook.
         * @summary Get a single webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWebhook', 'id', id)
            const localVarPath = `/api/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhook messages that receive too many attempts (failures) will not be sent again. You must first clear out old attempts before the message can go out again.
         * @summary Get all the failed attempts of a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessageAttempts: async (id: string, messageId: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWebhookMessageAttempts', 'id', id)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getWebhookMessageAttempts', 'messageId', messageId)
            const localVarPath = `/api/v1/webhooks/{id}/messages/{messageId}/attempts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When a webhook is triggered the actual message that will be send is stored in a \"message\". You can view and analyse these messages.
         * @summary Get all the messages of a single webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessages: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWebhookMessages', 'id', id)
            const localVarPath = `/api/v1/webhooks/{id}/messages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the user\'s webhooks.
         * @summary List all webhooks.
         * @param {number} [page] The page number, if necessary. The default pagination is 50, so 50 webhooks per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhook: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new webhook. The data required can be submitted as a JSON body or as a list of parameters. The webhook will be given a random secret. 
         * @summary Store a new webhook
         * @param {WebhookStore} webhookStore JSON array or key&#x3D;value pairs with the necessary webhook information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeWebhook: async (webhookStore: WebhookStore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookStore' is not null or undefined
            assertParamExists('storeWebhook', 'webhookStore', webhookStore)
            const localVarPath = `/api/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will submit any open messages for this webhook. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
         * @summary Submit messages for a webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitWebook: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitWebook', 'id', id)
            const localVarPath = `/api/v1/webhooks/{id}/submit`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing webhook\'s information. If you wish to reset the secret, submit any value as the \"secret\". Firefly III will take this as a hint and reset the secret of the webhook.
         * @summary Update existing webhook.
         * @param {string} id The webhook ID.
         * @param {WebhookUpdate} webhookUpdate JSON array with updated webhook information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (id: string, webhookUpdate: WebhookUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateWebhook', 'id', id)
            // verify required parameter 'webhookUpdate' is not null or undefined
            assertParamExists('updateWebhook', 'webhookUpdate', webhookUpdate)
            const localVarPath = `/api/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a webhook.
         * @summary Delete a webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a webhook message. Any time a webhook is triggered the message is stored before it\'s sent. You can delete them before or after sending.
         * @summary Delete a webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhookMessage(id: string, messageId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhookMessage(id, messageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a webhook message attempt. If you delete all attempts for a webhook message, Firefly III will (once again) assume all is well with the webhook message and will try to send it again.
         * @summary Delete a webhook attempt.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook message attempt ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhookMessageAttempt(id: string, messageId: number, attemptId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhookMessageAttempt(id, messageId, attemptId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When a webhook is triggered it will store the actual content of the webhook in a webhook message. You can view and analyse a single one using this endpoint.
         * @summary Get a single message from a webhook.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleWebhookMessage(id: string, messageId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookMessageSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleWebhookMessage(id, messageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhooks messages that receive too many attempts (failures) will not be fired. You must first clear out old attempts and try again. This endpoint shows you the details of a single attempt. The ID of the attempt must match the corresponding webhook and webhook message.
         * @summary Get a single failed attempt from a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook attempt ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleWebhookMessageAttempt(id: string, messageId: number, attemptId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookAttemptSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleWebhookMessageAttempt(id, messageId, attemptId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets all info of a single webhook.
         * @summary Get a single webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhook messages that receive too many attempts (failures) will not be sent again. You must first clear out old attempts before the message can go out again.
         * @summary Get all the failed attempts of a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhookMessageAttempts(id: string, messageId: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookAttemptArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhookMessageAttempts(id, messageId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When a webhook is triggered the actual message that will be send is stored in a \"message\". You can view and analyse these messages.
         * @summary Get all the messages of a single webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhookMessages(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookMessageArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhookMessages(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the user\'s webhooks.
         * @summary List all webhooks.
         * @param {number} [page] The page number, if necessary. The default pagination is 50, so 50 webhooks per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebhook(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhook(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new webhook. The data required can be submitted as a JSON body or as a list of parameters. The webhook will be given a random secret. 
         * @summary Store a new webhook
         * @param {WebhookStore} webhookStore JSON array or key&#x3D;value pairs with the necessary webhook information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeWebhook(webhookStore: WebhookStore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeWebhook(webhookStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will submit any open messages for this webhook. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
         * @summary Submit messages for a webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitWebook(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitWebook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing webhook\'s information. If you wish to reset the secret, submit any value as the \"secret\". Firefly III will take this as a hint and reset the secret of the webhook.
         * @summary Update existing webhook.
         * @param {string} id The webhook ID.
         * @param {WebhookUpdate} webhookUpdate JSON array with updated webhook information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(id: string, webhookUpdate: WebhookUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(id, webhookUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Delete a webhook.
         * @summary Delete a webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWebhook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a webhook message. Any time a webhook is triggered the message is stored before it\'s sent. You can delete them before or after sending.
         * @summary Delete a webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookMessage(id: string, messageId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWebhookMessage(id, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a webhook message attempt. If you delete all attempts for a webhook message, Firefly III will (once again) assume all is well with the webhook message and will try to send it again.
         * @summary Delete a webhook attempt.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook message attempt ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookMessageAttempt(id: string, messageId: number, attemptId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWebhookMessageAttempt(id, messageId, attemptId, options).then((request) => request(axios, basePath));
        },
        /**
         * When a webhook is triggered it will store the actual content of the webhook in a webhook message. You can view and analyse a single one using this endpoint.
         * @summary Get a single message from a webhook.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWebhookMessage(id: string, messageId: number, options?: any): AxiosPromise<WebhookMessageSingle> {
            return localVarFp.getSingleWebhookMessage(id, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhooks messages that receive too many attempts (failures) will not be fired. You must first clear out old attempts and try again. This endpoint shows you the details of a single attempt. The ID of the attempt must match the corresponding webhook and webhook message.
         * @summary Get a single failed attempt from a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook attempt ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWebhookMessageAttempt(id: string, messageId: number, attemptId: number, options?: any): AxiosPromise<WebhookAttemptSingle> {
            return localVarFp.getSingleWebhookMessageAttempt(id, messageId, attemptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all info of a single webhook.
         * @summary Get a single webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(id: string, options?: any): AxiosPromise<WebhookSingle> {
            return localVarFp.getWebhook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhook messages that receive too many attempts (failures) will not be sent again. You must first clear out old attempts before the message can go out again.
         * @summary Get all the failed attempts of a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessageAttempts(id: string, messageId: number, page?: number, options?: any): AxiosPromise<WebhookAttemptArray> {
            return localVarFp.getWebhookMessageAttempts(id, messageId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * When a webhook is triggered the actual message that will be send is stored in a \"message\". You can view and analyse these messages.
         * @summary Get all the messages of a single webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessages(id: string, options?: any): AxiosPromise<WebhookMessageArray> {
            return localVarFp.getWebhookMessages(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the user\'s webhooks.
         * @summary List all webhooks.
         * @param {number} [page] The page number, if necessary. The default pagination is 50, so 50 webhooks per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhook(page?: number, options?: any): AxiosPromise<WebhookArray> {
            return localVarFp.listWebhook(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new webhook. The data required can be submitted as a JSON body or as a list of parameters. The webhook will be given a random secret. 
         * @summary Store a new webhook
         * @param {WebhookStore} webhookStore JSON array or key&#x3D;value pairs with the necessary webhook information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeWebhook(webhookStore: WebhookStore, options?: any): AxiosPromise<WebhookSingle> {
            return localVarFp.storeWebhook(webhookStore, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will submit any open messages for this webhook. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
         * @summary Submit messages for a webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitWebook(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.submitWebook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing webhook\'s information. If you wish to reset the secret, submit any value as the \"secret\". Firefly III will take this as a hint and reset the secret of the webhook.
         * @summary Update existing webhook.
         * @param {string} id The webhook ID.
         * @param {WebhookUpdate} webhookUpdate JSON array with updated webhook information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(id: string, webhookUpdate: WebhookUpdate, options?: any): AxiosPromise<WebhookSingle> {
            return localVarFp.updateWebhook(id, webhookUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteWebhook operation in WebhooksApi.
 * @export
 * @interface WebhooksApiDeleteWebhookRequest
 */
export interface WebhooksApiDeleteWebhookRequest {
    /**
     * The webhook ID.
     * @type {string}
     * @memberof WebhooksApiDeleteWebhook
     */
    readonly id: string
}

/**
 * Request parameters for deleteWebhookMessage operation in WebhooksApi.
 * @export
 * @interface WebhooksApiDeleteWebhookMessageRequest
 */
export interface WebhooksApiDeleteWebhookMessageRequest {
    /**
     * The webhook ID.
     * @type {string}
     * @memberof WebhooksApiDeleteWebhookMessage
     */
    readonly id: string

    /**
     * The webhook message ID.
     * @type {number}
     * @memberof WebhooksApiDeleteWebhookMessage
     */
    readonly messageId: number
}

/**
 * Request parameters for deleteWebhookMessageAttempt operation in WebhooksApi.
 * @export
 * @interface WebhooksApiDeleteWebhookMessageAttemptRequest
 */
export interface WebhooksApiDeleteWebhookMessageAttemptRequest {
    /**
     * The webhook ID.
     * @type {string}
     * @memberof WebhooksApiDeleteWebhookMessageAttempt
     */
    readonly id: string

    /**
     * The webhook message ID.
     * @type {number}
     * @memberof WebhooksApiDeleteWebhookMessageAttempt
     */
    readonly messageId: number

    /**
     * The webhook message attempt ID.
     * @type {number}
     * @memberof WebhooksApiDeleteWebhookMessageAttempt
     */
    readonly attemptId: number
}

/**
 * Request parameters for getSingleWebhookMessage operation in WebhooksApi.
 * @export
 * @interface WebhooksApiGetSingleWebhookMessageRequest
 */
export interface WebhooksApiGetSingleWebhookMessageRequest {
    /**
     * The webhook ID.
     * @type {string}
     * @memberof WebhooksApiGetSingleWebhookMessage
     */
    readonly id: string

    /**
     * The webhook message ID.
     * @type {number}
     * @memberof WebhooksApiGetSingleWebhookMessage
     */
    readonly messageId: number
}

/**
 * Request parameters for getSingleWebhookMessageAttempt operation in WebhooksApi.
 * @export
 * @interface WebhooksApiGetSingleWebhookMessageAttemptRequest
 */
export interface WebhooksApiGetSingleWebhookMessageAttemptRequest {
    /**
     * The webhook ID.
     * @type {string}
     * @memberof WebhooksApiGetSingleWebhookMessageAttempt
     */
    readonly id: string

    /**
     * The webhook message ID.
     * @type {number}
     * @memberof WebhooksApiGetSingleWebhookMessageAttempt
     */
    readonly messageId: number

    /**
     * The webhook attempt ID.
     * @type {number}
     * @memberof WebhooksApiGetSingleWebhookMessageAttempt
     */
    readonly attemptId: number
}

/**
 * Request parameters for getWebhook operation in WebhooksApi.
 * @export
 * @interface WebhooksApiGetWebhookRequest
 */
export interface WebhooksApiGetWebhookRequest {
    /**
     * The webhook ID.
     * @type {string}
     * @memberof WebhooksApiGetWebhook
     */
    readonly id: string
}

/**
 * Request parameters for getWebhookMessageAttempts operation in WebhooksApi.
 * @export
 * @interface WebhooksApiGetWebhookMessageAttemptsRequest
 */
export interface WebhooksApiGetWebhookMessageAttemptsRequest {
    /**
     * The webhook ID.
     * @type {string}
     * @memberof WebhooksApiGetWebhookMessageAttempts
     */
    readonly id: string

    /**
     * The webhook message ID.
     * @type {number}
     * @memberof WebhooksApiGetWebhookMessageAttempts
     */
    readonly messageId: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof WebhooksApiGetWebhookMessageAttempts
     */
    readonly page?: number
}

/**
 * Request parameters for getWebhookMessages operation in WebhooksApi.
 * @export
 * @interface WebhooksApiGetWebhookMessagesRequest
 */
export interface WebhooksApiGetWebhookMessagesRequest {
    /**
     * The webhook ID.
     * @type {string}
     * @memberof WebhooksApiGetWebhookMessages
     */
    readonly id: string
}

/**
 * Request parameters for listWebhook operation in WebhooksApi.
 * @export
 * @interface WebhooksApiListWebhookRequest
 */
export interface WebhooksApiListWebhookRequest {
    /**
     * The page number, if necessary. The default pagination is 50, so 50 webhooks per page.
     * @type {number}
     * @memberof WebhooksApiListWebhook
     */
    readonly page?: number
}

/**
 * Request parameters for storeWebhook operation in WebhooksApi.
 * @export
 * @interface WebhooksApiStoreWebhookRequest
 */
export interface WebhooksApiStoreWebhookRequest {
    /**
     * JSON array or key&#x3D;value pairs with the necessary webhook information. See the model for the exact specifications.
     * @type {WebhookStore}
     * @memberof WebhooksApiStoreWebhook
     */
    readonly webhookStore: WebhookStore
}

/**
 * Request parameters for submitWebook operation in WebhooksApi.
 * @export
 * @interface WebhooksApiSubmitWebookRequest
 */
export interface WebhooksApiSubmitWebookRequest {
    /**
     * The webhook ID.
     * @type {string}
     * @memberof WebhooksApiSubmitWebook
     */
    readonly id: string
}

/**
 * Request parameters for updateWebhook operation in WebhooksApi.
 * @export
 * @interface WebhooksApiUpdateWebhookRequest
 */
export interface WebhooksApiUpdateWebhookRequest {
    /**
     * The webhook ID.
     * @type {string}
     * @memberof WebhooksApiUpdateWebhook
     */
    readonly id: string

    /**
     * JSON array with updated webhook information. See the model for the exact specifications.
     * @type {WebhookUpdate}
     * @memberof WebhooksApiUpdateWebhook
     */
    readonly webhookUpdate: WebhookUpdate
}

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Delete a webhook.
     * @summary Delete a webhook.
     * @param {WebhooksApiDeleteWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(requestParameters: WebhooksApiDeleteWebhookRequest, options?: any) {
        return WebhooksApiFp(this.configuration).deleteWebhook(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a webhook message. Any time a webhook is triggered the message is stored before it\'s sent. You can delete them before or after sending.
     * @summary Delete a webhook message.
     * @param {WebhooksApiDeleteWebhookMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhookMessage(requestParameters: WebhooksApiDeleteWebhookMessageRequest, options?: any) {
        return WebhooksApiFp(this.configuration).deleteWebhookMessage(requestParameters.id, requestParameters.messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a webhook message attempt. If you delete all attempts for a webhook message, Firefly III will (once again) assume all is well with the webhook message and will try to send it again.
     * @summary Delete a webhook attempt.
     * @param {WebhooksApiDeleteWebhookMessageAttemptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhookMessageAttempt(requestParameters: WebhooksApiDeleteWebhookMessageAttemptRequest, options?: any) {
        return WebhooksApiFp(this.configuration).deleteWebhookMessageAttempt(requestParameters.id, requestParameters.messageId, requestParameters.attemptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When a webhook is triggered it will store the actual content of the webhook in a webhook message. You can view and analyse a single one using this endpoint.
     * @summary Get a single message from a webhook.
     * @param {WebhooksApiGetSingleWebhookMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getSingleWebhookMessage(requestParameters: WebhooksApiGetSingleWebhookMessageRequest, options?: any) {
        return WebhooksApiFp(this.configuration).getSingleWebhookMessage(requestParameters.id, requestParameters.messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhooks messages that receive too many attempts (failures) will not be fired. You must first clear out old attempts and try again. This endpoint shows you the details of a single attempt. The ID of the attempt must match the corresponding webhook and webhook message.
     * @summary Get a single failed attempt from a single webhook message.
     * @param {WebhooksApiGetSingleWebhookMessageAttemptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getSingleWebhookMessageAttempt(requestParameters: WebhooksApiGetSingleWebhookMessageAttemptRequest, options?: any) {
        return WebhooksApiFp(this.configuration).getSingleWebhookMessageAttempt(requestParameters.id, requestParameters.messageId, requestParameters.attemptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all info of a single webhook.
     * @summary Get a single webhook.
     * @param {WebhooksApiGetWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhook(requestParameters: WebhooksApiGetWebhookRequest, options?: any) {
        return WebhooksApiFp(this.configuration).getWebhook(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhook messages that receive too many attempts (failures) will not be sent again. You must first clear out old attempts before the message can go out again.
     * @summary Get all the failed attempts of a single webhook message.
     * @param {WebhooksApiGetWebhookMessageAttemptsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhookMessageAttempts(requestParameters: WebhooksApiGetWebhookMessageAttemptsRequest, options?: any) {
        return WebhooksApiFp(this.configuration).getWebhookMessageAttempts(requestParameters.id, requestParameters.messageId, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When a webhook is triggered the actual message that will be send is stored in a \"message\". You can view and analyse these messages.
     * @summary Get all the messages of a single webhook.
     * @param {WebhooksApiGetWebhookMessagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhookMessages(requestParameters: WebhooksApiGetWebhookMessagesRequest, options?: any) {
        return WebhooksApiFp(this.configuration).getWebhookMessages(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the user\'s webhooks.
     * @summary List all webhooks.
     * @param {WebhooksApiListWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public listWebhook(requestParameters: WebhooksApiListWebhookRequest = {}, options?: any) {
        return WebhooksApiFp(this.configuration).listWebhook(requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new webhook. The data required can be submitted as a JSON body or as a list of parameters. The webhook will be given a random secret. 
     * @summary Store a new webhook
     * @param {WebhooksApiStoreWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public storeWebhook(requestParameters: WebhooksApiStoreWebhookRequest, options?: any) {
        return WebhooksApiFp(this.configuration).storeWebhook(requestParameters.webhookStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will submit any open messages for this webhook. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
     * @summary Submit messages for a webhook.
     * @param {WebhooksApiSubmitWebookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public submitWebook(requestParameters: WebhooksApiSubmitWebookRequest, options?: any) {
        return WebhooksApiFp(this.configuration).submitWebook(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing webhook\'s information. If you wish to reset the secret, submit any value as the \"secret\". Firefly III will take this as a hint and reset the secret of the webhook.
     * @summary Update existing webhook.
     * @param {WebhooksApiUpdateWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public updateWebhook(requestParameters: WebhooksApiUpdateWebhookRequest, options?: any) {
        return WebhooksApiFp(this.configuration).updateWebhook(requestParameters.id, requestParameters.webhookUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}
