/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v1.5.6
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2022-04-04T03:54:41+00:00 
 *
 * The version of the OpenAPI document: 1.5.6
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AttachmentArray } from '../model';
// @ts-ignore
import { BudgetArray } from '../model';
// @ts-ignore
import { BudgetLimit } from '../model';
// @ts-ignore
import { BudgetLimitArray } from '../model';
// @ts-ignore
import { BudgetLimitSingle } from '../model';
// @ts-ignore
import { BudgetLimitStore } from '../model';
// @ts-ignore
import { BudgetSingle } from '../model';
// @ts-ignore
import { BudgetStore } from '../model';
// @ts-ignore
import { BudgetUpdate } from '../model';
// @ts-ignore
import { TransactionArray } from '../model';
// @ts-ignore
import { TransactionTypeFilter } from '../model';
// @ts-ignore
import { ValidationError } from '../model';
/**
 * BudgetsApi - axios parameter creator
 * @export
 */
export const BudgetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a budget. Transactions will not be deleted.
         * @summary Delete a budget.
         * @param {string} id The ID of the budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudget: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBudget', 'id', id)
            const localVarPath = `/api/v1/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a budget limit.
         * @summary Delete a budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudgetLimit: async (id: string, limitId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBudgetLimit', 'id', id)
            // verify required parameter 'limitId' is not null or undefined
            assertParamExists('deleteBudgetLimit', 'limitId', limitId)
            const localVarPath = `/api/v1/budgets/{id}/limits/{limitId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"limitId"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single budget. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary Get a single budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudget: async (id: string, start?: string, end?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBudget', 'id', id)
            const localVarPath = `/api/v1/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get single budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {number} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetLimit: async (id: string, limitId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBudgetLimit', 'id', id)
            // verify required parameter 'limitId' is not null or undefined
            assertParamExists('getBudgetLimit', 'limitId', limitId)
            const localVarPath = `/api/v1/budgets/{id}/limits/{limitId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"limitId"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments of a budget.
         * @param {string} id The ID of the budget.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByBudget: async (id: string, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAttachmentByBudget', 'id', id)
            const localVarPath = `/api/v1/budgets/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the budgets the user has made. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary List all budgets.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudget: async (page?: number, start?: string, end?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all budget limits for for this date range. 
         * @summary Get list of budget limits by date
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimit: async (start: string, end: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('listBudgetLimit', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('listBudgetLimit', 'end', end)
            const localVarPath = `/api/v1/budget-limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \"spent\" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself. 
         * @summary Get all limits for a budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimitByBudget: async (id: string, start?: string, end?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listBudgetLimitByBudget', 'id', id)
            const localVarPath = `/api/v1/budgets/{id}/limits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all transactions linked to a budget, possibly limited by start and end
         * @summary All transactions to a budget.
         * @param {string} id The ID of the budget.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudget: async (id: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listTransactionByBudget', 'id', id)
            const localVarPath = `/api/v1/budgets/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
         * @summary List all transactions by a budget limit ID.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudgetLimit: async (id: string, limitId: string, page?: number, type?: TransactionTypeFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listTransactionByBudgetLimit', 'id', id)
            // verify required parameter 'limitId' is not null or undefined
            assertParamExists('listTransactionByBudgetLimit', 'limitId', limitId)
            const localVarPath = `/api/v1/budgets/{id}/limits/{limitId}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"limitId"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all transactions without a budget, possibly limited by start and end
         * @summary All transactions without a budget.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionWithoutBudget: async (limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/budgets/transactions-without-budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new budget
         * @param {BudgetStore} budgetStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudget: async (budgetStore: BudgetStore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetStore' is not null or undefined
            assertParamExists('storeBudget', 'budgetStore', budgetStore)
            const localVarPath = `/api/v1/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budgetStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store a new budget limit under this budget.
         * @summary Store new budget limit.
         * @param {string} id The ID of the budget.
         * @param {BudgetLimitStore} budgetLimitStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudgetLimit: async (id: string, budgetLimitStore: BudgetLimitStore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storeBudgetLimit', 'id', id)
            // verify required parameter 'budgetLimitStore' is not null or undefined
            assertParamExists('storeBudgetLimit', 'budgetLimitStore', budgetLimitStore)
            const localVarPath = `/api/v1/budgets/{id}/limits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budgetLimitStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing budget. This endpoint cannot be used to set budget amount limits.
         * @summary Update existing budget.
         * @param {string} id The ID of the budget.
         * @param {BudgetUpdate} budgetUpdate JSON array with updated budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudget: async (id: string, budgetUpdate: BudgetUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBudget', 'id', id)
            // verify required parameter 'budgetUpdate' is not null or undefined
            assertParamExists('updateBudget', 'budgetUpdate', budgetUpdate)
            const localVarPath = `/api/v1/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budgetUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing budget limit.
         * @summary Update existing budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {BudgetLimit} budgetLimit JSON array with updated budget limit information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudgetLimit: async (id: string, limitId: string, budgetLimit: BudgetLimit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBudgetLimit', 'id', id)
            // verify required parameter 'limitId' is not null or undefined
            assertParamExists('updateBudgetLimit', 'limitId', limitId)
            // verify required parameter 'budgetLimit' is not null or undefined
            assertParamExists('updateBudgetLimit', 'budgetLimit', budgetLimit)
            const localVarPath = `/api/v1/budgets/{id}/limits/{limitId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"limitId"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budgetLimit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BudgetsApi - functional programming interface
 * @export
 */
export const BudgetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BudgetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a budget. Transactions will not be deleted.
         * @summary Delete a budget.
         * @param {string} id The ID of the budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBudget(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBudget(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a budget limit.
         * @summary Delete a budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBudgetLimit(id: string, limitId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBudgetLimit(id, limitId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single budget. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary Get a single budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBudget(id: string, start?: string, end?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBudget(id, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get single budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {number} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBudgetLimit(id: string, limitId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetLimitSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBudgetLimit(id, limitId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments of a budget.
         * @param {string} id The ID of the budget.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentByBudget(id: string, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentByBudget(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the budgets the user has made. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary List all budgets.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBudget(page?: number, start?: string, end?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBudget(page, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all budget limits for for this date range. 
         * @summary Get list of budget limits by date
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBudgetLimit(start: string, end: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetLimitArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBudgetLimit(start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \"spent\" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself. 
         * @summary Get all limits for a budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBudgetLimitByBudget(id: string, start?: string, end?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetLimitArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBudgetLimitByBudget(id, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all transactions linked to a budget, possibly limited by start and end
         * @summary All transactions to a budget.
         * @param {string} id The ID of the budget.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByBudget(id: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByBudget(id, limit, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
         * @summary List all transactions by a budget limit ID.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByBudgetLimit(id: string, limitId: string, page?: number, type?: TransactionTypeFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByBudgetLimit(id, limitId, page, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all transactions without a budget, possibly limited by start and end
         * @summary All transactions without a budget.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionWithoutBudget(limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionWithoutBudget(limit, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new budget
         * @param {BudgetStore} budgetStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeBudget(budgetStore: BudgetStore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeBudget(budgetStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Store a new budget limit under this budget.
         * @summary Store new budget limit.
         * @param {string} id The ID of the budget.
         * @param {BudgetLimitStore} budgetLimitStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeBudgetLimit(id: string, budgetLimitStore: BudgetLimitStore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetLimitSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeBudgetLimit(id, budgetLimitStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing budget. This endpoint cannot be used to set budget amount limits.
         * @summary Update existing budget.
         * @param {string} id The ID of the budget.
         * @param {BudgetUpdate} budgetUpdate JSON array with updated budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBudget(id: string, budgetUpdate: BudgetUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBudget(id, budgetUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing budget limit.
         * @summary Update existing budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {BudgetLimit} budgetLimit JSON array with updated budget limit information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBudgetLimit(id: string, limitId: string, budgetLimit: BudgetLimit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetLimitSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBudgetLimit(id, limitId, budgetLimit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BudgetsApi - factory interface
 * @export
 */
export const BudgetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BudgetsApiFp(configuration)
    return {
        /**
         * Delete a budget. Transactions will not be deleted.
         * @summary Delete a budget.
         * @param {string} id The ID of the budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudget(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBudget(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a budget limit.
         * @summary Delete a budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudgetLimit(id: string, limitId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBudgetLimit(id, limitId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single budget. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary Get a single budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudget(id: string, start?: string, end?: string, options?: any): AxiosPromise<BudgetSingle> {
            return localVarFp.getBudget(id, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get single budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {number} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetLimit(id: string, limitId: number, options?: any): AxiosPromise<BudgetLimitSingle> {
            return localVarFp.getBudgetLimit(id, limitId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments of a budget.
         * @param {string} id The ID of the budget.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByBudget(id: string, page?: number, options?: any): AxiosPromise<AttachmentArray> {
            return localVarFp.listAttachmentByBudget(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the budgets the user has made. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary List all budgets.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudget(page?: number, start?: string, end?: string, options?: any): AxiosPromise<BudgetArray> {
            return localVarFp.listBudget(page, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all budget limits for for this date range. 
         * @summary Get list of budget limits by date
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimit(start: string, end: string, options?: any): AxiosPromise<BudgetLimitArray> {
            return localVarFp.listBudgetLimit(start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \"spent\" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself. 
         * @summary Get all limits for a budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimitByBudget(id: string, start?: string, end?: string, options?: any): AxiosPromise<BudgetLimitArray> {
            return localVarFp.listBudgetLimitByBudget(id, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all transactions linked to a budget, possibly limited by start and end
         * @summary All transactions to a budget.
         * @param {string} id The ID of the budget.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudget(id: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByBudget(id, limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
         * @summary List all transactions by a budget limit ID.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudgetLimit(id: string, limitId: string, page?: number, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByBudgetLimit(id, limitId, page, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all transactions without a budget, possibly limited by start and end
         * @summary All transactions without a budget.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionWithoutBudget(limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionWithoutBudget(limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new budget
         * @param {BudgetStore} budgetStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudget(budgetStore: BudgetStore, options?: any): AxiosPromise<BudgetSingle> {
            return localVarFp.storeBudget(budgetStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Store a new budget limit under this budget.
         * @summary Store new budget limit.
         * @param {string} id The ID of the budget.
         * @param {BudgetLimitStore} budgetLimitStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudgetLimit(id: string, budgetLimitStore: BudgetLimitStore, options?: any): AxiosPromise<BudgetLimitSingle> {
            return localVarFp.storeBudgetLimit(id, budgetLimitStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing budget. This endpoint cannot be used to set budget amount limits.
         * @summary Update existing budget.
         * @param {string} id The ID of the budget.
         * @param {BudgetUpdate} budgetUpdate JSON array with updated budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudget(id: string, budgetUpdate: BudgetUpdate, options?: any): AxiosPromise<BudgetSingle> {
            return localVarFp.updateBudget(id, budgetUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing budget limit.
         * @summary Update existing budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {BudgetLimit} budgetLimit JSON array with updated budget limit information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudgetLimit(id: string, limitId: string, budgetLimit: BudgetLimit, options?: any): AxiosPromise<BudgetLimitSingle> {
            return localVarFp.updateBudgetLimit(id, limitId, budgetLimit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiDeleteBudgetRequest
 */
export interface BudgetsApiDeleteBudgetRequest {
    /**
     * The ID of the budget.
     * @type {string}
     * @memberof BudgetsApiDeleteBudget
     */
    readonly id: string
}

/**
 * Request parameters for deleteBudgetLimit operation in BudgetsApi.
 * @export
 * @interface BudgetsApiDeleteBudgetLimitRequest
 */
export interface BudgetsApiDeleteBudgetLimitRequest {
    /**
     * The ID of the budget. The budget limit MUST be associated to the budget ID.
     * @type {string}
     * @memberof BudgetsApiDeleteBudgetLimit
     */
    readonly id: string

    /**
     * The ID of the budget limit. The budget limit MUST be associated to the budget ID.
     * @type {string}
     * @memberof BudgetsApiDeleteBudgetLimit
     */
    readonly limitId: string
}

/**
 * Request parameters for getBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiGetBudgetRequest
 */
export interface BudgetsApiGetBudgetRequest {
    /**
     * The ID of the requested budget.
     * @type {string}
     * @memberof BudgetsApiGetBudget
     */
    readonly id: string

    /**
     * A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
     * @type {string}
     * @memberof BudgetsApiGetBudget
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
     * @type {string}
     * @memberof BudgetsApiGetBudget
     */
    readonly end?: string
}

/**
 * Request parameters for getBudgetLimit operation in BudgetsApi.
 * @export
 * @interface BudgetsApiGetBudgetLimitRequest
 */
export interface BudgetsApiGetBudgetLimitRequest {
    /**
     * The ID of the budget. The budget limit MUST be associated to the budget ID.
     * @type {string}
     * @memberof BudgetsApiGetBudgetLimit
     */
    readonly id: string

    /**
     * The ID of the budget limit. The budget limit MUST be associated to the budget ID.
     * @type {number}
     * @memberof BudgetsApiGetBudgetLimit
     */
    readonly limitId: number
}

/**
 * Request parameters for listAttachmentByBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiListAttachmentByBudgetRequest
 */
export interface BudgetsApiListAttachmentByBudgetRequest {
    /**
     * The ID of the budget.
     * @type {string}
     * @memberof BudgetsApiListAttachmentByBudget
     */
    readonly id: string

    /**
     * Page number. The default pagination is 50.
     * @type {number}
     * @memberof BudgetsApiListAttachmentByBudget
     */
    readonly page?: number
}

/**
 * Request parameters for listBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiListBudgetRequest
 */
export interface BudgetsApiListBudgetRequest {
    /**
     * Page number. The default pagination is 50.
     * @type {number}
     * @memberof BudgetsApiListBudget
     */
    readonly page?: number

    /**
     * A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
     * @type {string}
     * @memberof BudgetsApiListBudget
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
     * @type {string}
     * @memberof BudgetsApiListBudget
     */
    readonly end?: string
}

/**
 * Request parameters for listBudgetLimit operation in BudgetsApi.
 * @export
 * @interface BudgetsApiListBudgetLimitRequest
 */
export interface BudgetsApiListBudgetLimitRequest {
    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof BudgetsApiListBudgetLimit
     */
    readonly start: string

    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof BudgetsApiListBudgetLimit
     */
    readonly end: string
}

/**
 * Request parameters for listBudgetLimitByBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiListBudgetLimitByBudgetRequest
 */
export interface BudgetsApiListBudgetLimitByBudgetRequest {
    /**
     * The ID of the requested budget.
     * @type {string}
     * @memberof BudgetsApiListBudgetLimitByBudget
     */
    readonly id: string

    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof BudgetsApiListBudgetLimitByBudget
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof BudgetsApiListBudgetLimitByBudget
     */
    readonly end?: string
}

/**
 * Request parameters for listTransactionByBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiListTransactionByBudgetRequest
 */
export interface BudgetsApiListTransactionByBudgetRequest {
    /**
     * The ID of the budget.
     * @type {string}
     * @memberof BudgetsApiListTransactionByBudget
     */
    readonly id: string

    /**
     * Limits the number of results on one page.
     * @type {number}
     * @memberof BudgetsApiListTransactionByBudget
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is 50.
     * @type {number}
     * @memberof BudgetsApiListTransactionByBudget
     */
    readonly page?: number

    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof BudgetsApiListTransactionByBudget
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof BudgetsApiListTransactionByBudget
     */
    readonly end?: string

    /**
     * Optional filter on the transaction type(s) returned
     * @type {TransactionTypeFilter}
     * @memberof BudgetsApiListTransactionByBudget
     */
    readonly type?: TransactionTypeFilter
}

/**
 * Request parameters for listTransactionByBudgetLimit operation in BudgetsApi.
 * @export
 * @interface BudgetsApiListTransactionByBudgetLimitRequest
 */
export interface BudgetsApiListTransactionByBudgetLimitRequest {
    /**
     * The ID of the budget. The budget limit MUST be associated to the budget ID.
     * @type {string}
     * @memberof BudgetsApiListTransactionByBudgetLimit
     */
    readonly id: string

    /**
     * The ID of the budget limit. The budget limit MUST be associated to the budget ID.
     * @type {string}
     * @memberof BudgetsApiListTransactionByBudgetLimit
     */
    readonly limitId: string

    /**
     * Page number. The default pagination is 50.
     * @type {number}
     * @memberof BudgetsApiListTransactionByBudgetLimit
     */
    readonly page?: number

    /**
     * Optional filter on the transaction type(s) returned
     * @type {TransactionTypeFilter}
     * @memberof BudgetsApiListTransactionByBudgetLimit
     */
    readonly type?: TransactionTypeFilter
}

/**
 * Request parameters for listTransactionWithoutBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiListTransactionWithoutBudgetRequest
 */
export interface BudgetsApiListTransactionWithoutBudgetRequest {
    /**
     * Limits the number of results on one page.
     * @type {number}
     * @memberof BudgetsApiListTransactionWithoutBudget
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is 50.
     * @type {number}
     * @memberof BudgetsApiListTransactionWithoutBudget
     */
    readonly page?: number

    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof BudgetsApiListTransactionWithoutBudget
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof BudgetsApiListTransactionWithoutBudget
     */
    readonly end?: string

    /**
     * Optional filter on the transaction type(s) returned
     * @type {TransactionTypeFilter}
     * @memberof BudgetsApiListTransactionWithoutBudget
     */
    readonly type?: TransactionTypeFilter
}

/**
 * Request parameters for storeBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiStoreBudgetRequest
 */
export interface BudgetsApiStoreBudgetRequest {
    /**
     * JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
     * @type {BudgetStore}
     * @memberof BudgetsApiStoreBudget
     */
    readonly budgetStore: BudgetStore
}

/**
 * Request parameters for storeBudgetLimit operation in BudgetsApi.
 * @export
 * @interface BudgetsApiStoreBudgetLimitRequest
 */
export interface BudgetsApiStoreBudgetLimitRequest {
    /**
     * The ID of the budget.
     * @type {string}
     * @memberof BudgetsApiStoreBudgetLimit
     */
    readonly id: string

    /**
     * JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
     * @type {BudgetLimitStore}
     * @memberof BudgetsApiStoreBudgetLimit
     */
    readonly budgetLimitStore: BudgetLimitStore
}

/**
 * Request parameters for updateBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiUpdateBudgetRequest
 */
export interface BudgetsApiUpdateBudgetRequest {
    /**
     * The ID of the budget.
     * @type {string}
     * @memberof BudgetsApiUpdateBudget
     */
    readonly id: string

    /**
     * JSON array with updated budget information. See the model for the exact specifications.
     * @type {BudgetUpdate}
     * @memberof BudgetsApiUpdateBudget
     */
    readonly budgetUpdate: BudgetUpdate
}

/**
 * Request parameters for updateBudgetLimit operation in BudgetsApi.
 * @export
 * @interface BudgetsApiUpdateBudgetLimitRequest
 */
export interface BudgetsApiUpdateBudgetLimitRequest {
    /**
     * The ID of the budget. The budget limit MUST be associated to the budget ID.
     * @type {string}
     * @memberof BudgetsApiUpdateBudgetLimit
     */
    readonly id: string

    /**
     * The ID of the budget limit. The budget limit MUST be associated to the budget ID.
     * @type {string}
     * @memberof BudgetsApiUpdateBudgetLimit
     */
    readonly limitId: string

    /**
     * JSON array with updated budget limit information. See the model for the exact specifications.
     * @type {BudgetLimit}
     * @memberof BudgetsApiUpdateBudgetLimit
     */
    readonly budgetLimit: BudgetLimit
}

/**
 * BudgetsApi - object-oriented interface
 * @export
 * @class BudgetsApi
 * @extends {BaseAPI}
 */
export class BudgetsApi extends BaseAPI {
    /**
     * Delete a budget. Transactions will not be deleted.
     * @summary Delete a budget.
     * @param {BudgetsApiDeleteBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public deleteBudget(requestParameters: BudgetsApiDeleteBudgetRequest, options?: any) {
        return BudgetsApiFp(this.configuration).deleteBudget(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a budget limit.
     * @summary Delete a budget limit.
     * @param {BudgetsApiDeleteBudgetLimitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public deleteBudgetLimit(requestParameters: BudgetsApiDeleteBudgetLimitRequest, options?: any) {
        return BudgetsApiFp(this.configuration).deleteBudgetLimit(requestParameters.id, requestParameters.limitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single budget. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
     * @summary Get a single budget.
     * @param {BudgetsApiGetBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public getBudget(requestParameters: BudgetsApiGetBudgetRequest, options?: any) {
        return BudgetsApiFp(this.configuration).getBudget(requestParameters.id, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get single budget limit.
     * @param {BudgetsApiGetBudgetLimitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public getBudgetLimit(requestParameters: BudgetsApiGetBudgetLimitRequest, options?: any) {
        return BudgetsApiFp(this.configuration).getBudgetLimit(requestParameters.id, requestParameters.limitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all attachments.
     * @summary Lists all attachments of a budget.
     * @param {BudgetsApiListAttachmentByBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listAttachmentByBudget(requestParameters: BudgetsApiListAttachmentByBudgetRequest, options?: any) {
        return BudgetsApiFp(this.configuration).listAttachmentByBudget(requestParameters.id, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the budgets the user has made. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
     * @summary List all budgets.
     * @param {BudgetsApiListBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listBudget(requestParameters: BudgetsApiListBudgetRequest = {}, options?: any) {
        return BudgetsApiFp(this.configuration).listBudget(requestParameters.page, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all budget limits for for this date range. 
     * @summary Get list of budget limits by date
     * @param {BudgetsApiListBudgetLimitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listBudgetLimit(requestParameters: BudgetsApiListBudgetLimitRequest, options?: any) {
        return BudgetsApiFp(this.configuration).listBudgetLimit(requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \"spent\" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself. 
     * @summary Get all limits for a budget.
     * @param {BudgetsApiListBudgetLimitByBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listBudgetLimitByBudget(requestParameters: BudgetsApiListBudgetLimitByBudgetRequest, options?: any) {
        return BudgetsApiFp(this.configuration).listBudgetLimitByBudget(requestParameters.id, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all transactions linked to a budget, possibly limited by start and end
     * @summary All transactions to a budget.
     * @param {BudgetsApiListTransactionByBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listTransactionByBudget(requestParameters: BudgetsApiListTransactionByBudgetRequest, options?: any) {
        return BudgetsApiFp(this.configuration).listTransactionByBudget(requestParameters.id, requestParameters.limit, requestParameters.page, requestParameters.start, requestParameters.end, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
     * @summary List all transactions by a budget limit ID.
     * @param {BudgetsApiListTransactionByBudgetLimitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listTransactionByBudgetLimit(requestParameters: BudgetsApiListTransactionByBudgetLimitRequest, options?: any) {
        return BudgetsApiFp(this.configuration).listTransactionByBudgetLimit(requestParameters.id, requestParameters.limitId, requestParameters.page, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all transactions without a budget, possibly limited by start and end
     * @summary All transactions without a budget.
     * @param {BudgetsApiListTransactionWithoutBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listTransactionWithoutBudget(requestParameters: BudgetsApiListTransactionWithoutBudgetRequest = {}, options?: any) {
        return BudgetsApiFp(this.configuration).listTransactionWithoutBudget(requestParameters.limit, requestParameters.page, requestParameters.start, requestParameters.end, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new budget
     * @param {BudgetsApiStoreBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public storeBudget(requestParameters: BudgetsApiStoreBudgetRequest, options?: any) {
        return BudgetsApiFp(this.configuration).storeBudget(requestParameters.budgetStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Store a new budget limit under this budget.
     * @summary Store new budget limit.
     * @param {BudgetsApiStoreBudgetLimitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public storeBudgetLimit(requestParameters: BudgetsApiStoreBudgetLimitRequest, options?: any) {
        return BudgetsApiFp(this.configuration).storeBudgetLimit(requestParameters.id, requestParameters.budgetLimitStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing budget. This endpoint cannot be used to set budget amount limits.
     * @summary Update existing budget.
     * @param {BudgetsApiUpdateBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public updateBudget(requestParameters: BudgetsApiUpdateBudgetRequest, options?: any) {
        return BudgetsApiFp(this.configuration).updateBudget(requestParameters.id, requestParameters.budgetUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing budget limit.
     * @summary Update existing budget limit.
     * @param {BudgetsApiUpdateBudgetLimitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public updateBudgetLimit(requestParameters: BudgetsApiUpdateBudgetLimitRequest, options?: any) {
        return BudgetsApiFp(this.configuration).updateBudgetLimit(requestParameters.id, requestParameters.limitId, requestParameters.budgetLimit, options).then((request) => request(this.axios, this.basePath));
    }
}
